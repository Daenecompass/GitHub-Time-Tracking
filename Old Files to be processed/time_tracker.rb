require 'octokit'
require 'chronic_duration'
require 'mongo'
require 'pp'

class GitHubTimeTracking
	include Mongo

	def controller(repo, username, password)
		self.gh_Authenticate(username, password)
		self.mongo_Connect

		@collTimeTrackingCommits.remove

		issues = self.get_Issues(repo)
		
		# goes through each issue returned from get_Issues method
		issues.each do |i|

			dog = self.process_issue(repo, i)
			if dog.empty? == false
				self.putIntoMongoCollTimeTrackingCommits(dog)
			end


		# 	issueNumber = i.attrs[:number]

		# 	issueTime = self.get_issue_time(repo, issueNumber)
		# 	issueBudget = self.get_issue_budget(repo, issueNumber)
		# 	if issueTime.empty? == false
		# 		self.putIntoMongoCollTimeTrackingCommits(issueTime)
		# 	end
		# 	if issueBudget.empty? == false
		# 		self.putIntoMongoCollTimeTrackingCommits(issueBudget)
		# 	end	
		end

		# milestoneBudgets = self.get_milestone_budget(repo)
		# repoCommits = self.get_commits_messages(repo)
		# if milestoneBudgets.empty? == false
		# 	self.putIntoMongoCollTimeTrackingCommits(milestoneBudgets)
		# end
		# if repoCommits.empty? == false
		# 	self.putIntoMongoCollTimeTrackingCommits(repoCommits)
		# end


		# # Tasks Processing BETA code:

		# commentBody1 = "Cat\r\n\r\nDog\r\n\r\n- [ ] :clock1: :free: 1h | Task Name 1\r\n- [ ] Task Name 2\r\n\r\n- [ ] Task Name 3\r\n- [x] Tast Complete 1\r\n\r\ncats \r\n\r\n- [x] Task name Complete 1\r\n\r\n\r\n- [ ] Task Name 4"
		# dog = self.get_comment_tasks(commentBody1, :incomplete)
		# puts dog
		# puts self.get_time_from_commment_tasks(dog, :incomplete)
	end

	def process_issue(repo, issueDetails)
		# output = {}
		
		type = "Issue Time"
		issueState = issueDetails.attrs[:state]
		issueTitle = issueDetails.attrs[:title]
		issueNumber = issueDetails.attrs[:number]
		issueCreatedAt = issueDetails.attrs[:created_at]
		issueClosedAt = issueDetails.attrs[:closed_at]
		issueLastUpdatedAt = issueDetails.attrs[:updated_at]
		recordCreationDate = Time.now.utc
		
		# gets the milestone number assigned to a issue.  Is not milestone assigned then returns nil
		milestoneNumber = get_issue_milestone_number(issueDetails.attrs[:milestone])
		
		#gets labels data for issue and returns array of label strings
		labelNames = get_label_names(issueDetails.attrs[:labels])
		
		# runs the label names through a parser to create Label categories.  
		# used for advanced label grouping
		labels = process_issue_labels(labelNames)
		
		# gets the comments of the specific issue being processed
		issueComments = get_Issue_Comments(repo, issueDetails.attrs[:number])

		commentsTime = []

		# cycles through each comment and returns time tracking 
		issueComments.each do |x|
			# checks to see if there is a time comment in the body field
			isTimeComment = self.time_comment?(x.attrs[:body])
			if isTimeComment == true
				# if true, the body field is parsed for time comment details
				parsedTime = self.process_issue_comment_for_time(x)
				if parsedTime != nil
					# assuming results are returned from the parse (aka the parse was preceived 
					# by the code to be sucessful, the parsed time comment details array is put into
					# the commentsTime array)
					commentsTime << parsedTime
				end
			end
		end

		return output = { "type" => type,
							"repo" => repo,
							"issue_state" => issueState,
							"issue_title" => issueTitle,
							"issue_number" => issueNumber,
							"milestone_number" => milestoneNumber,
							"labels" => labels,
							"issue_created_at" => issueCreatedAt,
							"issue_closed_at" => issueClosedAt,
							"issue_last_updated_at" => issueLastUpdatedAt,
							"record_creation_date" => recordCreationDate,
							"time_commits" => commentsTime, }	
	end

	def mongo_Connect
		# MongoDB Database Connect
		@client = MongoClient.new("localhost", 27017)

		# code for working with MongoLab
		# uri = "mongodb://USERNAME:PASSWORD@ds061268.mongolab.com:61268/TimeTrackingCommits"
		# @client = MongoClient.from_uri(uri)

		@db = @client["GitHub-TimeTracking"]

		@collTimeTrackingCommits = @db["TimeTrackingCommits"]
	end

	def putIntoMongoCollTimeTrackingCommits(mongoPayload)
		@collTimeTrackingCommits.insert(mongoPayload)
	end

	def gh_Authenticate(username, password)
		@ghClient = Octokit::Client.new(
										:login => username.to_s, 
										:password => password.to_s, 
										:auto_paginate => true
										)
	end




	def get_Issues(repo)
		issueResultsOpen = @ghClient.list_issues(repo, {
			:state => :open
			})
		issueResultsClosed = @ghClient.list_issues(repo, {
			:state => :closed
			})

		return mergedIssues = issueResultsOpen + issueResultsClosed
	end

	def get_Milestones(repo)
		milestonesResultsOpen = @ghClient.list_milestones(repo, {
			:state => :open
			})
		milestonesResultsClosed = @ghClient.list_milestones(repo, {
			:state => :closed
			})

		return mergedMilestones = milestonesResultsOpen + milestonesResultsClosed
	end

	def get_Issue_Comments(repo, issueNumber)
		return @ghClient.issue_comments(repo, issueNumber)
	end





	def accepted_time_comment_emoji(*acceptedTimeCommentEmoji)
		acceptedTimeCommentEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
								":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
								":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
								":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
								":clock4:", ":clock530:", ":clock7:", ":clock830:"]
	end

	def accepted_nonBillable_emoji(*acceptedNonBilliableEmoji)
		acceptedNonBilliableEmoji = [":free:"]
	end

	# Is it a time comment?  Returns True or False
	def time_comment?(commentBody)
		acceptedClockEmoji = self.accepted_time_comment_emoji

		# acceptedClockEmoji.any? { |w| commentBody.attrs[:body] =~ /\A#{w}/ }
		acceptedClockEmoji.any? { |w| commentBody =~ /\A#{w}/ }
	end

	# Is it a budget comment?
	def budget_comment?(commentBody)
		acceptedBudgetEmoji = [":dart:"]

		return acceptedClockEmoji.any? { |w| commentBody.attrs[:body] =~ /\A#{w}/ }
	end

	# does the comment contain the :free: emoji that indicates its non-billable
	def non_billable?(commentBody)
		acceptedNonBilliableEmoji = [":free:"]
		# TODO come up with better regex for checking to see if it is a valud billable
		return acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
	end

	# parse through GitHub labels and return label names in an array
	def get_label_names(labels)
		issueLabels = []
		if labels != nil
			labels.each do |x|
				issueLabels << x["name"]
			end
		end
		return issueLabels
	end

	# Gets the milestone ID number assigned to the issue
	def get_issue_milestone_number(milestoneDetails)
		if milestoneDetails != nil
			return milestoneDetails.attrs[:number]
		end
	end

	# parses the durationText variable through ChronicDuration
	def get_duration(durationText)
		return ChronicDuration.parse(durationText)
	end


	def parse_time_commit(timeComment, nonBillableTime)
		acceptedClockEmoji = self.accepted_time_comment_emoji
		acceptedNonBilliableEmoji = self.accepted_nonBillable_emoji

		parsedCommentHash = { "duration" => nil, "non_billable" => nil, "work_date" => nil, "time_comment" => nil}
		parsedComment = []
		acceptedClockEmoji.each do |x|
			if nonBillableTime == true
				acceptedNonBilliableEmoji.each do |b|
					if timeComment =~ /\A#{x}\s#{b}/
						parsedComment = self.parse_non_billable_time_comment(timeComment,x,b)
						parsedCommentHash["non_billable"] = true
						break
					end
				end
			elsif nonBillableTime == false
				if timeComment =~ /\A#{x}/
					parsedComment = self.parse_billable_time_comment(timeComment,x)
					parsedCommentHash["non_billable"] = false
					break
				end
			end
		end
		if parsedComment.empty? == true
			return nil
		end

		if parsedComment[0] != nil
			parsedCommentHash["duration"] = self.get_duration(parsedComment[0])
		end
		if parsedComment[1] != nil
			workDate = self.get_time_work_date(parsedComment[1])
				if workDate != nil
					parsedCommentHash["work_date"] = workDate
				elsif workDate == nil
					parsedCommentHash["time_comment"] = self.get_time_commit_comment(parsedComment[1])
				end
		end
		if parsedComment[2] != nil
			parsedCommentHash["time_comment"] = self.get_time_commit_comment(parsedComment[2])
		end

		return parsedCommentHash
	end






	def parse_billable_time_comment(timeComment, timeEmoji)
		return timeComment.gsub("#{timeEmoji} ","").split(" | ")
	end

	def parse_non_billable_time_comment(timeComment, timeEmoji, nonBillableEmoji)
		return timeComment.gsub("#{timeEmoji} #{nonBillableEmoji} ","").split(" | ")
	end

	def get_time_work_date(parsedTimeComment)
		begin
			return Time.parse(parsedTimeComment).utc
		rescue
			return nil
		end
	end

	def get_time_commit_comment(parsedTimeComment)
		return parsedTimeComment.lstrip.gsub("\r\n", " ")
	end

	# processes a comment for time comment information
	def process_issue_comment_for_time(issueComment)

		issueCommentBody = issueComment.attrs[:body]
		nonBillable = self.non_billable?(issueCommentBody)
		parsedTimeDetails = self.parse_time_commit(issueCommentBody, nonBillable)
		if parsedTimeDetails == nil
			return nil
		else
			overviewDetails = {"comment_id" => issueComment.attrs[:id],
								"work_logged_by" => issueComment.attrs[:user].attrs[:login],
								"comment_created_date" => issueComment.attrs[:created_at],
								"comment_last_updated_date" =>issueComment.attrs[:updated_at],
								"record_creation_date" => Time.now.utc}
			mergedHash = parsedTimeDetails.merge(overviewDetails)
			return mergedHash
		end
	end









	def get_issue_time(repo, issueNumber)
		output = []
		acceptedClockEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
								":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
								":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
								":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
								":clock4:", ":clock530:", ":clock7:", ":clock830:"]
		acceptedNonBilliableEmoji = [":free:"]
		issueComments = @ghClient.issue_comments(repo, issueNumber)
		issueDetails = @ghClient.issue(repo, issueNumber)
		
		# Cycle through each comment in the issue
		issueComments.each do |c|
			parsedComment = nil
			timeComment = nil
			assignedMilestoneNumber = nil

			commentBody = c.attrs[:body]

			# Check if any of the accepted Clock emoji are in the begining of the comment
			if acceptedClockEmoji.any? { |w| commentBody =~ /\A#{w}/ }

				isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
				commentId = c.attrs[:id]
				userCreated = c.attrs[:user].attrs[:login]
				createdAtDate = c.attrs[:created_at]
				updatedAtDate = c.attrs[:updated_at]
				issueState = issueDetails[:state]
				issueTitle = issueDetails[:title]
				type = "Issue Time"
				recordCreationDate = Time.now.utc

				issueLabels = []
				if issueDetails[:labels] !=nil
					issueDetails[:labels].each do |x|
						issueLabels << x["name"]
					end
					issueLabels = self.process_issue_labels(issueLabels)
				end
				

				if issueDetails[:milestone] != nil
					assignedMilestoneNumber = issueDetails[:milestone].attrs[:number]
				end

				acceptedClockEmoji.each do |x|
					if commentBody.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedComment = commentBody.gsub("#{x} #{b}","").split(" | ")
							end
						else
							parsedComment = commentBody.gsub("#{x} ","").split(" | ")
						end
					end
				end
				# Parse first value as a duration
				# TODO add support for duration not be parsed correctly. (use case is that the clock emoji is used in a regular comment that is not part of a time commit)
				duration = ChronicDuration.parse(parsedComment[0])
				
				# Is there anything more than a duration value?
				if parsedComment[1].nil?
					workDate = nil
				else
					begin
						# Determine if the second item is a Date.
						# Try to parse the item as a Date
						workDate = Time.parse(parsedComment[1]).utc
					rescue
						# If date parse is invalid then we assume second item is not a date
						# We assume it is not a date then it is treated as a comment
						if parsedComment[1].nil? == false
							timeComment = parsedComment[1].lstrip.gsub("\r\n", " ")
						end
					end
					# if there is a Druation and a Date then there will be a third item in the array
					# If there is a third item then we treat it as a comment
					if parsedComment[2].nil? == false
						timeComment = parsedComment[2].lstrip.gsub("\r\n", " ")
					end
				end
				
				timeCommitHash = {"type" => type,
									"duration" => duration,
									"non_billable" => isNonBilliableTime,
									"work_date" => workDate,
									"time_description" => timeComment,
									"comment_id" => commentId,
									"comment_created_date" => createdAtDate,
									"work_logged_by" => userCreated,
									"issue_number" => issueNumber,
									"repo_name" => repo,
									"issue_title" => issueTitle,
									"issue_state" => issueState,
									"assigned_milestone_number" => assignedMilestoneNumber,
									"issue_labels" => issueLabels,
									"record_creation_date" => recordCreationDate
								}
				output << timeCommitHash
			end
		end
		return output
	end

	def get_issue_budget(repo, issueNumber)

		output = []
		acceptedBudgetEmoji = [":dart:"]
		acceptedNonBilliableEmoji = [":free:"]
		issueComments = @ghClient.issue_comments(repo, issueNumber)
		issueDetails = @ghClient.issue(repo, issueNumber)
		
		# Cycle through each comment in the issue
		issueComments.each do |c|
			parsedComment = nil
			budgetComment = nil
			assignedMilestoneNumber = nil

			commentBody = c.attrs[:body]

			# Check if any of the accepted emoji are in the comment
			if acceptedBudgetEmoji.any? { |w| commentBody =~ /\A#{w}/ }

				isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
				commentId = c.attrs[:id]
				userCreated = c.attrs[:user].attrs[:login]
				createdAtDate = c.attrs[:created_at]
				updatedAtDate = c.attrs[:updated_at]
				issueState = issueDetails[:state]
				issueTitle = issueDetails[:title]
				type = "Issue Budget"
				recordCreationDate = Time.now.utc

				issueLabels = []
				if issueDetails[:labels] !=nil
					issueDetails[:labels].each do |x|
						issueLabels << x["name"]
					end
					issueLabels = self.process_issue_labels(issueLabels)
				end


				if issueDetails[:milestone] != nil
					assignedMilestoneNumber = issueDetails[:milestone].attrs[:number]
				end

				acceptedBudgetEmoji.each do |x|
					if commentBody.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedComment = commentBody.gsub("#{x} #{b}","").split(" | ")
							end
						else
							parsedComment = commentBody.gsub("#{x} ","").split(" | ")
						end
					end
				end

				budgetDuration = ChronicDuration.parse(parsedComment[0])
				
				if parsedComment[1].nil? == false
					budgetComment = parsedComment[1].lstrip.gsub("\r\n", " ")
				end
				
				budgetCommitHash = {"type" => type,
									"duration" => budgetDuration,
									"non_billable" => isNonBilliableTime,
									"budget_description" => budgetComment,
									"comment_id" => commentId,
									"comment_created_date" => createdAtDate,
									"budget_logged_by" => userCreated,
									"issue_number" => issueNumber,
									"repo_name" => repo,
									"issue_state" => issueState,
									"issue_title" => issueTitle,
									"assigned_milestone_number" => assignedMilestoneNumber,
									"issue_labels" => issueLabels,
									"record_creation_date" => recordCreationDate
								}
				output << budgetCommitHash
			end
		end
		return output
	end

	def get_milestone_budget (repo, milestones = nil)
		
		output = []
		if milestones == nil
			milestones = self.get_Milestones(repo)
		end

		acceptedBudgetEmoji = [":dart:"]
		acceptedNonBilliableEmoji = [":free:"]
		
		# Cycle through each milestone
		milestones.each do |c|
			parsedDescription = []
			budgetComment = nil

			commentBody = c.attrs[:description]

			# Check if any of the accepted emoji are in the comment
			if acceptedBudgetEmoji.any? { |w| commentBody =~ /\A#{w}/ }

				isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
				milestoneTitle = c.attrs[:title]
				milestoneNumber = c.attrs[:number]
				createdAtDate = c.attrs[:created_at]
				milestoneState = c.attrs[:state]
				milestoneDueDate = c.attrs[:due_on]
				type = "Milestone Budget"
				recordCreationDate = Time.now.utc

				acceptedBudgetEmoji.each do |x|
					if commentBody.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedDescription = commentBody.gsub("#{x} #{b}","").split(" | ")
							end
						else
							parsedDescription = commentBody.gsub("#{x} ","").split(" | ")
						end
					end
				end

				# Parse first value as a duration
				# TODO add error catching for improper duration format.
				duration = ChronicDuration.parse(parsedDescription[0])
				
				if parsedDescription[1].nil? == false
					budgetComment = parsedDescription[1].lstrip.gsub("\r\n", " ")
				end
				
				milestoneBudgetHash = {"type" => type,
									"duration" => duration,
									"non_billable" => isNonBilliableTime,
									"milestone_due_date" => milestoneDueDate,
									"budget_description" => budgetComment,
									"milestone_number" => milestoneNumber,
									"milestone_created_date" => createdAtDate,
									"repo_name" => repo,
									"milestone_state" => milestoneState,
									"milestone_title" => milestoneTitle,
									"record_creation_date" => recordCreationDate
								}
				output << milestoneBudgetHash
			end
		end
		return output
	end 

	def get_commit_comments(repo, sha)

		commitComments = @ghClient.commit_comments(repo, sha)
		commitCommentsArray = []

		acceptedClockEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
								":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
								":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
								":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
								":clock4:", ":clock530:", ":clock7:", ":clock830:"]
		acceptedNonBilliableEmoji = [":free:"]
		
		# Cycle through each comment in the issue
		commitComments.each do |c|
			parsedComment = nil
			timeComment = nil

			commentBody = c.attrs[:body]

			# Check if any of the accepted Clock emoji are in the comment
			if acceptedClockEmoji.any? { |w| commentBody =~ /\A#{w}/ }

				isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
				commentId = c.attrs[:id]
				userCreated = c.attrs[:user].attrs[:login]
				createdAtDate = c.attrs[:created_at]
				updatedAtDate = c.attrs[:updated_at]
				type = "Code Commit Comment Time"
				recordCreationDate = Time.now.utc
				commentForPath = c.attrs[:path]
				commentForLine = c.attrs[:line]

				acceptedClockEmoji.each do |x|
					if commentBody.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedComment = commentBody.gsub("#{x} #{b}","").split(" | ")
							end
						else
							parsedComment = commentBody.gsub("#{x} ","").split(" | ")
						end
					end
				end

				# Parse first value as a duration
				# TODO add support for duration not be parsed correctly. (use case is that the clock emoji is used in a regular comment that is not part of a time commit)
				duration = ChronicDuration.parse(parsedComment[0])
				
				# Is there anything more than a duration value?
				if parsedComment[1].nil?
					workDate = nil
				else
					begin
						# Determine if the second item is a Date.
						# Try to parse the item as a Date
						workDate = Time.parse(parsedComment[1]).utc
					rescue
						# If date parse is invalid then we assume second item is not a date
						# We assume it is not a date then it is treated as a comment
						if parsedComment[1].nil? == false
							timeComment = parsedComment[1].lstrip.gsub("\r\n", " ")
						end
					end
					# if there is a Druation and a Date then there will be a third item in the array
					# If there is a third item then we treat it as a comment
					if parsedComment[2].nil? == false
						timeComment = parsedComment[2].lstrip.gsub("\r\n", " ")
					end
				end
				
				timeCommitHash = {"type" => type,
									"duration" => duration,
									"non_billable" => isNonBilliableTime,
									"work_date" => workDate,
									"time_description" => timeComment,
									"comment_id" => commentId,
									"comment_created_date" => createdAtDate,
									"work_logged_by" => userCreated,
									"path" => commentForPath,
									"line" => commentForLine,
									"record_creation_date" => recordCreationDate
								}
				commitCommentsArray << timeCommitHash
			end
		end
		return commitCommentsArray
	end

	def get_commits_messages(repo, *ghOptions)

		output = []
		repoCommits = @ghClient.commits(repo, ghOptions)

		repoCommits.each do |c|

			acceptedClockEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
									":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
									":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
									":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
									":clock4:", ":clock530:", ":clock7:", ":clock830:"]
			acceptedNonBilliableEmoji = [":free:"]

			parsedComment = nil
			timeComment = nil
			commitParentsShas = []

			commitSha = c.attrs[:sha]
			commitComments = self.get_commit_comments(repo, commitSha)			
			commitMessage = c.attrs[:commit].attrs[:message]

			# Check if any of the accepted Clock emoji are in the comment
			timeInCommitMessageYN = acceptedClockEmoji.any? { |w| commitMessage =~ /\A#{w}/ }

			type = "Code Commit Time"
			recordCreationDate = Time.now.utc

			commitAuthorUsername = c.attrs[:author].attrs[:login]
			commitAuthorDate =  c.attrs[:commit].attrs[:author].attrs[:date]
			commitCommitterUsername =  c.attrs[:committer].attrs[:login]
			commitCommitterDate = c.attrs[:commit].attrs[:committer].attrs[:date]
			commitTreeSha = c.attrs[:commit].attrs[:tree].attrs[:sha]
			if c.attrs[:parents] != nil
				c.attrs[:parents].each do |x|
					commitParentsShas << x.attrs[:sha]
				end
			end
			isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commitMessage =~ /#{b}/ }
				
			if timeInCommitMessageYN == true
				acceptedClockEmoji.each do |x|
					if commitMessage.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedComment = commitMessage.gsub("#{x} #{b}","").split(" | ")
							end
						else
							parsedComment = commitMessage.gsub("#{x} ","").split(" | ")
						end
					end
				end

				duration = ChronicDuration.parse(parsedComment[0])
				
				# Is there anything more than a duration value?
				if parsedComment[1].nil?
					workDate = nil
				else
					begin
						# Determine if the second item is a Date.
						# Try to parse the item as a Date
						workDate = Time.parse(parsedComment[1]).utc
					rescue
						# If date parse is invalid then we assume second item is not a date
						# We assume it is not a date then it is treated as a comment
						if parsedComment[1].nil? == false
							timeComment = parsedComment[1].lstrip.gsub("\r\n", " ")
						end
					end
					# if there is a Druation and a Date then there will be a third item in the array
					# If there is a third item then we treat it as a comment
					if parsedComment[2].nil? == false
						timeComment = parsedComment[2].lstrip.gsub("\r\n", " ")
					end
				end
			end
				
			timeCommitHash = {"type" => type,
								"repo_name" => repo,
								"duration" => duration,
								"non_billable" => isNonBilliableTime,
								"work_date" => workDate,
								"commit_message" => timeComment,
								"commit_author_username" => commitAuthorUsername,
								"commit_author_date" => commitAuthorDate,
								"commit_committer_username" => commitCommitterUsername,
								"commit_committer_date" => commitCommitterDate,
								"commit_sha" => commitSha,
								"commit_tree_sha" => commitTreeSha,
								"commit_parents_shas" => commitParentsShas,
								"commit_comments" => commitComments
							}

			unless timeCommitHash["duration"] == nil and timeCommitHash["commit_comments"].empty? == true
				output << timeCommitHash
			end
		end
		return output
	end

	def process_issue_labels(ghLabels, options = {})
		output = []
		outputHash = {}
		
		if options[:acceptedLabels] == nil
			# Exaple/Default labels.
			acceptedLabels = [
								{:category => "Priority:", :label => "Low"},
								{:category => "Priority:", :label => "Medium"},
								{:category => "Priority:", :label => "High"},
								{:category => "Size:", :label => "Small"},
								{:category => "Size:", :label => "Medium"},
								{:category => "Size:", :label => "Large"},
								{:category => "Version:", :label => "1.0"},
								{:category => "Version:", :label => "1.5"},
								{:category => "Version:", :label => "2.0"},
								{:category => "Task:", :label => "Medium"},
								{:category => "Size:", :label => "Medium"},
							]
		end

		if ghLabels != nil
			ghLabels.each do |x|
				if acceptedLabels.any? { |b| [b[:category],b[:label]].join(" ") == x } == true
					acceptedLabels.each do |y|
						if [y[:category], y[:label]].join(" ") == x
							outputHash["Category"] = y[:category][0..-2]
							outputHash["Label"] = y[:label]
							output << outputHash
						end
					end
				else
					outputHash["Category"] = nil
					outputHash["Label"] = x
					output << outputHash
				end
			end
		else
			output = []
		end
		return output
	end

	def get_comment_tasks (commentBody, taskState = :incomplete)

		tasks = []
		startStringIncomplete = /\-\s\[\s\]\s/
		startStringComplete = /\-\s\[x\]\s/

		endString = /[\r\n]|\z/

		if taskState == :incomplete
			tasksInBody = commentBody.scan(/#{startStringIncomplete}(.*?)#{endString}/)
			tasksInBody.each do |x|
				tasks << x[0]
			end
		elsif taskState == :complete
			tasksInBody = commentBody.scan(/#{startStringComplete}(.*?)#{endString}/)
			tasksInBody.each do |x|
				tasks << x[0]
			end
		end
		return tasks
	end

	def get_time_from_commment_tasks (tasksText, taskState)
		output = []
		acceptedClockEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
						":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
						":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
						":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
						":clock4:", ":clock530:", ":clock7:", ":clock830:"]
		acceptedNonBilliableEmoji = [":free:"]


		tasksText.each do |commentBody|

			if acceptedClockEmoji.any? { |w| commentBody =~ /\A#{w}/ } == true
				workDate = nil
				parsedComment = nil
				type = "Task Time"
				recordCreationDate = Time.now.utc

				isNonBilliableTime = acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }

				acceptedClockEmoji.each do |x|
					if commentBody.gsub!("#{x} ","") != nil
						if isNonBilliableTime == true
							acceptedNonBilliableEmoji.each do |b|
								parsedComment = commentBody.gsub("#{x} #{b}","").split(" | ")
								break
							end
						else
							parsedComment = commentBody.gsub("#{x} ","").split(" | ")
							break
						end
					end
				end
				# Parse first value as a duration
				duration = ChronicDuration.parse(parsedComment[0])
				
				# Is there anything more than a duration value?
				if parsedComment[1].nil?
					workDate = nil
				else
					begin
						# Determine if the second item is a Date.
						# Try to parse the item as a Date
						workDate = Time.parse(parsedComment[1]).utc
					rescue
						# If date parse is invalid then we assume second item is not a date
						# We assume it is not a date then it is treated as a comment
						if parsedComment[1].nil? == false
							timeComment = parsedComment[1].lstrip.gsub("\r\n", " ")
						end
					end
					# if there is a Druation and a Date then there will be a third item in the array
					# If there is a third item then we treat it as a comment
					if parsedComment[2].nil? == false
						timeComment = parsedComment[2].lstrip.gsub("\r\n", " ")
					end
				end
				taskTimeCommitHash = {"type" => type,
									"duration" => duration,
									"non_billable" => isNonBilliableTime,
									"work_date" => workDate,
									"time_description" => timeComment,
									"tasks_state" => taskState.to_s,
									"record_creation_date" => recordCreationDate
								}
				output << taskTimeCommitHash
			end
		end
		return output
	end

	def time_task_non_billable?(taskBody)
		acceptedNonBilliableEmoji = [":free:"]
		
		return acceptedNonBilliableEmoji.any? { |b| commentBody =~ /#{b}/ }
	end

	def time_task?(taskBody)
		acceptedClockEmoji = [":clock130:", ":clock11:", ":clock1230:", ":clock3:", ":clock430:", 
								":clock6:", ":clock730:", ":clock9:", ":clock10:", ":clock1130:", 
								":clock2:", ":clock330:", ":clock5:", ":clock630:", ":clock8:", 
								":clock930:", ":clock1:", ":clock1030:", ":clock12:", ":clock230:", 
								":clock4:", ":clock530:", ":clock7:", ":clock830:"]

		return acceptedClockEmoji.any? { |w| taskBody =~ /\A#{w}/ }
	end
end

start = GitHubTimeTracking.new
start.controller("StephenOTT/Test1", "USERNAME", "PASSWORD")


